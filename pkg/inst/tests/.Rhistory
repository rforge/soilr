?[[]]
?"[[<-"
a=list()
a[[1]]<-5
a
?"[[<-"
atrr([[]])
attributes([[]])
attributes([[)
attributes("[[")
?"[[<-"
source("prolog.R")
source("prolog.R")
source("prolog.R")
method.skeleton("[[<-","MCSim")
l=list("1 3","2 1","3 2")
l
as.character(l)
grep("1*",l)
grepl("1*",l)
grepl("1 *",l)
grepl("^1 *",l)
grepl("^1*",l)
i=4
class(i)=
class(i)
class(i)
l
l=list()
l[[1,1]]=5
l[["1,1"]]=5
?grepl
names=c("a","b")
names
make.names(names)
data.frame(make.names(names))
data.frame(names)
data.frame(eval(names))
data.frame(names,stringsAsFactors=T)
matrix(names,stringsAsFactors=T)
matrix(names)
?matrix-class
?matrix
matrix(nrow=3,ncol=3,dimnames=names)
names=list("a","b")
matrix(nrow=3,ncol=3,dimnames=names)
matrix(nrow=3,ncol=2,dimnames=names)
names=list(c("a","b"),c("a","b"))
names
matrix(nrow=3,ncol=2,dimnames=names)
matrix(nrow=2,ncol=2,dimnames=names)
matrix(dimnames=names)
matrix(dimnames=names[1])
names[1]
matrix(ncol=length(names[1]),dimnames=names[1])
matrix(ncol=length(names[[1]]),dimnames=names[1])
length(names[[1]])
matrix(ncol=length(names[[1]]))
matrix(ncol=length(names[[1]]),dimnames=list(c("a",b)))
matrix(ncol=length(names[[1]]),dimnames=list(c("a","b")))
matrix(ncol=length(names[[1]]),dimnames=list(c(),c("a","b")))
matrix(ncol=length(names[[1]]),nrow=0,dimnames=list(c(),c("a","b")))
as.data.frame(matrix(ncol=length(names[[1]]),nrow=0,dimnames=list(c(),c("a","b"))))
as.data.frame(matrix(ncol=length(names[[1]]),nrow=0,dimnames=list(c(),c("a","b"))))
# create the operator for a three pool feedback model
# according to our new general definition
#
t_start=0
t_end=50
tn=40
timestep=(t_end-t_start)/tn
t=seq(t_start,t_end,timestep)
nr=3
nc=3
# define the transfer functions for the model
# we could compile them to a matrix valued
# Function of C and t since they will be
# applied in a linear way on the output vector.
# but we rather store them in an indexed list
# (as a sparse matrix) which also has some
# implementational benefits because the single
# functions are easier to retrieve from the operator
# if needed.
alpha=list()
alpha[["2_to_1"]]=function(C,t){
1/4*1e-16
}
alpha[["3_to_2"]]=function(C,t){
1/3*1e-16
}
alpha[["1_to_2"]]=function(C,t){
1/2#*1e-16
}
k1=-1e-1
k2=-2/3
k3=-1
f=function(C,t){
# in this case the application of f can be expressed by a matrix multiplication
# f(C,t)=N C
# furthermorde the matrix N is actually completely linear and even constant
N=matrix(
nrow=nr,
ncol=nc,
c(
k1,    0,     0,
0  ,  k2,     0,
0,     0,    k3
)
)
# so we can write f(C,t)  as a Matrix product
# note however that we could anything we like with the components
# of C here.
# The only thing to take care of is that we release a vector of the same
# size as C
return(N%*%C)
}
c01=1e4
c02=0
c03=2.5
inputrates=new("TimeMap",t_start,t_end,function(t){return(matrix(
nrow=nr,
rep(
c(
2e3,  2,  3
),
length(t)
)
))})
A=new("TransportDecompositionOperator",t_start,Inf,nr,alpha,f)
mod=GeneralNlModel(
t,
A,
c(
c01,
c02,
c03
),
inputrates,
deSolve.lsoda.wrapper
)
# Now we first solve  the solution Ode with our standard solver
# we don't have to do this with the particle simulation
# we rather use the results there
source("prolog.R")
# create the operator for a three pool feedback model
# according to our new general definition
#
t_start=0
t_end=50
tn=40
timestep=(t_end-t_start)/tn
t=seq(t_start,t_end,timestep)
nr=3
nc=3
# define the transfer functions for the model
# we could compile them to a matrix valued
# Function of C and t since they will be
# applied in a linear way on the output vector.
# but we rather store them in an indexed list
# (as a sparse matrix) which also has some
# implementational benefits because the single
# functions are easier to retrieve from the operator
# if needed.
alpha=list()
alpha[["2_to_1"]]=function(C,t){
1/4*1e-16
}
alpha[["3_to_2"]]=function(C,t){
1/3*1e-16
}
alpha[["1_to_2"]]=function(C,t){
1/2#*1e-16
}
k1=-1e-1
k2=-2/3
k3=-1
f=function(C,t){
# in this case the application of f can be expressed by a matrix multiplication
# f(C,t)=N C
# furthermorde the matrix N is actually completely linear and even constant
N=matrix(
nrow=nr,
ncol=nc,
c(
k1,    0,     0,
0  ,  k2,     0,
0,     0,    k3
)
)
# so we can write f(C,t)  as a Matrix product
# note however that we could anything we like with the components
# of C here.
# The only thing to take care of is that we release a vector of the same
# size as C
return(N%*%C)
}
c01=1e4
c02=0
c03=2.5
inputrates=new("TimeMap",t_start,t_end,function(t){return(matrix(
nrow=nr,
rep(
c(
2e3,  2,  3
),
length(t)
)
))})
A=new("TransportDecompositionOperator",t_start,Inf,nr,alpha,f)
mod=GeneralNlModel(
t,
A,
c(
c01,
c02,
c03
),
inputrates,
deSolve.lsoda.wrapper
)
# Now we first solve  the solution Ode with our standard solver
# we don't have to do this with the particle simulation
# we rather use the results there
as.data.frame(matrix(ncol=length(names[[1]]),nrow=0,dimnames=list(c(),c("a","b"))))
[1] a b
<0 Zeilen> (oder row.names mit LÃ¤nge 0)
Fehler: Unerwartete(s) '<' in "<"
Tr=getTransferCoefficients(mod,as.closures=TRUE)
names(Tr)
